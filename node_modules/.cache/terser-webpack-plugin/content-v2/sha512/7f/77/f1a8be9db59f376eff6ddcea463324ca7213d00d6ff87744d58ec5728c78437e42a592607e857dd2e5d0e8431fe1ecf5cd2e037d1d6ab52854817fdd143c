{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{455:function(v,_,l){\"use strict\";l.r(_);var i=l(2),p=Object(i.a)({},(function(){var v=this,_=v._self._c;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[_(\"h2\",{attrs:{id:\"jvm探究\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#jvm探究\"}},[v._v(\"#\")]),v._v(\" JVM探究\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"请你谈谈对JVM的理解? JAVA8虚拟机和之前的变化?\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"什么是OOM, 什么是栈溢出? 怎么分析?\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"JVM的常用调优参数?\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"内存快照如何抓取, 怎么分析Dump文件?知道吗?\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"谈谈JVM中, 类加载器你的认识?\")])])]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"p\",[v._v(\"JVM的位置\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"在操作系统之上, 相当于一个虚拟机软件\")])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"JVM的体系结构\")]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"C:%5CUsers%5Cucmed%5CAppData%5CRoaming%5Cmarktext%5Cimages%5C2023-11-12-15-39-38-image.png\",alt:\"\"}})])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"类加载器\")]),v._v(\" \"),_(\"p\",[v._v(\"作用: 加载class文件\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"p\",[v._v(\"虚拟机自带的加载器\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"启动类(根)加载器\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"扩展类加载器\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"应用程序加载器\")])])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"双亲委派机制\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"类加载器在加载一个类的时候会先看这个类是否被加载过, 如果没有会委托父类加载器去加载\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"如果父类加载器还有父类加载器, 就继续向上委托直到启动类加载器\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"然后看是否可以完成加载, 成功就返回. 如果不能加载, 子类加载器才会尝试去加载\")])])]),v._v(\" \"),_(\"div\",{staticClass:\"language-markdown extra-class\"},[_(\"pre\",{pre:!0,attrs:{class:\"language-markdown\"}},[_(\"code\",[v._v(\"优点:\\n避免类的重复加载\\n保护程序安全, 防止核心API被篡改\\n\\n缺点:\\n在某些场景下双亲委派记至过于局限, 所以有时候需要打破双亲委派机制\\n\")])])]),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"JDBC打破双亲委派机制\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"DriverManager因为是在rt.jar包下面, 所以会被启动类加载器加载\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"而DriverManager的实现类是第三方提供的, 不能被启动类加载器加载\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"这个时候JDBC通过引入ThreadContextClassLoader(线程上下文加载器, 默认是AppClassLoader)的方式来使用应用程序类加载器, 破坏了双亲委派机制\")])])])])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"沙箱安全机制(了解)\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"Native\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"凡是带了\"),_(\"code\",[v._v(\"native\")]),v._v(\"关键字的会进入本地方法栈, 调用本地方法接口\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"Java诞生的时候, C,C++横行, 想要立足, 必须要有调用它们的程序\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"Java在内存中专门开辟了一块标记区域: \"),_(\"code\",[v._v(\"Native Method Stack\")]),v._v(\", 登记\"),_(\"code\",[v._v(\"Native\")]),v._v(\"方法\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"在最终执行的时候, 加载本地方法库中的方法通过\"),_(\"code\",[v._v(\"JNI\")])])])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"PC寄存器\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"程序计数器\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"因为代码是在线程中运行的, 线程有可能被挂起. 即CPU一会执行A线程, 一会执行B线程, 等它再切换回A线程的时候程序计数器会告诉CPU执行到哪了\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"每个线程都有一个程序计数器, 是线程私有的, 就是一个指针,指向方法区中的方法字节码(用来存储指向下一条指令的地址, 也就是将要执行的指令代码),在执行引擎读取下一条指令,是一个非常小的内存空间,几乎可以忽略不计\")])])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"方法区\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"p\",[v._v(\"方法区是被所有线程共享, 所有字段和方法字节码, 以及一些特殊方法, 如构造函数, 接口代码也在此定义, 简单说, 所有定义的方法信息都保存在该区域, 此区域属于\"),_(\"strong\",[v._v(\"共享区域\")])])]),v._v(\" \"),_(\"li\",[_(\"p\",[_(\"mark\",[v._v(\"静态变量, 常量, 类信息(构造方法, 接口定义), 运行时的常量池存在方法区中, 但实例变量存在堆内存中, 和方法区无关\")])])])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"栈: 数据结构\")]),v._v(\" \"),_(\"p\",[v._v(\"程序 = 数据结构 + 算法\")]),v._v(\" \"),_(\"p\",[v._v(\"栈: 先进后出, 后进先出: 桶\")]),v._v(\" \"),_(\"p\",[v._v(\"队列: 先进先出(FIFO: first input first output) : 排队\")]),v._v(\" \"),_(\"p\",[v._v(\"为什么main()最先执行, 最后结束?\")]),v._v(\" \"),_(\"p\",[v._v(\"栈: 栈内存, 主管程序的运行, 生命周期和线程同步; 线程结束, 栈内存就释放, 对于栈来说\"),_(\"mark\",[v._v(\"不存在垃圾回收问题\")]),v._v(\", 一旦线程结束, 栈就Over!\")]),v._v(\" \"),_(\"p\",[v._v(\"栈: 8大基本类型 + 对象引用 + 实例的方法\")]),v._v(\" \"),_(\"p\",[v._v(\"栈运行原理:\")]),v._v(\" \"),_(\"p\",[v._v(\"以栈帧的形式\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"三种JVM\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"堆\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"新生区, 老年区\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"永久区\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"堆内存调优\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"GC\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[v._v(\"常用算法\")])])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"JMM\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"总结\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"百度\")])]),v._v(\" \"),_(\"li\",[_(\"p\",[v._v(\"思维导图\")])])])])}),[],!1,null,null,null);_.default=p.exports}}]);","extractedComments":[]}