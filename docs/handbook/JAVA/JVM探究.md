## JVM探究

- 请你谈谈对JVM的理解? JAVA8虚拟机和之前的变化?

- 什么是OOM, 什么是栈溢出? 怎么分析?

- JVM的常用调优参数?

- 内存快照如何抓取, 怎么分析Dump文件?知道吗?

- 谈谈JVM中, 类加载器你的认识?
1. JVM的位置
   
   - 在操作系统之上, 相当于一个虚拟机软件

2. JVM的体系结构
   
   ![](C:\Users\ucmed\AppData\Roaming\marktext\images\2023-11-12-15-39-38-image.png)

3. 类加载器
   
   作用: 加载class文件
   
   1. 虚拟机自带的加载器
   
   2. 启动类(根)加载器
   
   3. 扩展类加载器
   
   4. 应用程序加载器

4. 双亲委派机制
   
   - 类加载器在加载一个类的时候会先看这个类是否被加载过, 如果没有会委托父类加载器去加载
   
   - 如果父类加载器还有父类加载器, 就继续向上委托直到启动类加载器
   
   - 然后看是否可以完成加载, 成功就返回. 如果不能加载, 子类加载器才会尝试去加载
   
   ```markdown
   优点:
   避免类的重复加载
   保护程序安全, 防止核心API被篡改
   
   缺点:
   在某些场景下双亲委派记至过于局限, 所以有时候需要打破双亲委派机制
   ```
   
   - JDBC打破双亲委派机制
     
     - DriverManager因为是在rt.jar包下面, 所以会被启动类加载器加载
     
     - 而DriverManager的实现类是第三方提供的, 不能被启动类加载器加载
     
     - 这个时候JDBC通过引入ThreadContextClassLoader(线程上下文加载器, 默认是AppClassLoader)的方式来使用应用程序类加载器, 破坏了双亲委派机制

5. 沙箱安全机制(了解)

6. Native
   
   - 凡是带了`native`关键字的会进入本地方法栈, 调用本地方法接口
   
   - Java诞生的时候, C,C++横行, 想要立足, 必须要有调用它们的程序
   
   - Java在内存中专门开辟了一块标记区域: `Native Method Stack`, 登记`Native`方法
   
   - 在最终执行的时候, 加载本地方法库中的方法通过`JNI`

7. PC寄存器
   
   - 程序计数器
   
   - 因为代码是在线程中运行的, 线程有可能被挂起. 即CPU一会执行A线程, 一会执行B线程, 等它再切换回A线程的时候程序计数器会告诉CPU执行到哪了
   
   - 每个线程都有一个程序计数器, 是线程私有的, 就是一个指针,指向方法区中的方法字节码(用来存储指向下一条指令的地址, 也就是将要执行的指令代码),在执行引擎读取下一条指令,是一个非常小的内存空间,几乎可以忽略不计

8. 方法区
   
   - 方法区是被所有线程共享, 所有字段和方法字节码, 以及一些特殊方法, 如构造函数, 接口代码也在此定义, 简单说, 所有定义的方法信息都保存在该区域, 此区域属于**共享区域**
   
   - <mark>静态变量, 常量, 类信息(构造方法, 接口定义), 运行时的常量池存在方法区中, 但实例变量存在堆内存中, 和方法区无关</mark>

9. 栈: 数据结构
   
   程序 = 数据结构 + 算法
   
   栈: 先进后出, 后进先出: 桶
   
   队列: 先进先出(FIFO: first input first output) : 排队
   
   为什么main()最先执行, 最后结束?
   
   栈: 栈内存, 主管程序的运行, 生命周期和线程同步; 线程结束, 栈内存就释放, 对于栈来说<mark>不存在垃圾回收问题</mark>, 一旦线程结束, 栈就Over!
   
   栈: 8大基本类型 + 对象引用 + 实例的方法
   
   栈运行原理:
   
   以栈帧的形式

10. 三种JVM

11. 堆

12. 新生区, 老年区

13. 永久区

14. 堆内存调优

15. GC
    
    1. 常用算法

16. JMM

17. 总结

18. 百度

19. 思维导图
